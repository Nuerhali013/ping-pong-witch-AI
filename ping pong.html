<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ping Pong Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #2c3e50, #4a5568);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Arial', sans-serif;
        }

        .game-container {
            background: #1a202c;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        }

        .scoreboard {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 0 20px;
        }

        .player-score {
            color: #e53e3e;
            font-size: 24px;
            font-weight: bold;
        }

        .vs-text {
            color: #a0aec0;
            font-size: 18px;
            font-weight: bold;
        }

        .difficulty {
            color: #a0aec0;
            font-size: 14px;
        }

        .bot-score {
            color: #3182ce;
            font-size: 24px;
            font-weight: bold;
        }

        .game-canvas {
            border: 8px solid #000;
            background: #48bb78;
            display: block;
            border-radius: 10px;
        }

        .controls {
            text-align: center;
            margin-top: 20px;
            color: #a0aec0;
        }

        .difficulty-selector {
            margin-top: 15px;
            text-align: center;
        }

        .difficulty-btn {
            background: #4a5568;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 0 5px;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .difficulty-btn:hover {
            background: #2d3748;
        }

        .difficulty-btn.active {
            background: #3182ce;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="scoreboard">
            <div>
                <div style="color: #e53e3e; font-size: 16px;">YOU</div>
                <div class="player-score" id="playerScore">0</div>
            </div>
            <div class="vs-text">
                <div class="difficulty" id="difficultyText">MEDIUM</div>
                <div>VS</div>
            </div>
            <div>
                <div style="color: #3182ce; font-size: 16px;">BOT</div>
                <div class="bot-score" id="botScore">0</div>
            </div>
        </div>
        
        <canvas id="gameCanvas" class="game-canvas" width="600" height="400"></canvas>
        
        <div class="controls">
            <p>Move your mouse up/down to control the paddle</p>
            <p>First to 5 points wins!</p>
        </div>
        
        <div class="difficulty-selector">
            <button class="difficulty-btn" onclick="setDifficulty('easy')">Easy</button>
            <button class="difficulty-btn active" onclick="setDifficulty('medium')">Medium</button>
            <button class="difficulty-btn" onclick="setDifficulty('hard')">Hard</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const playerScoreEl = document.getElementById('playerScore');
        const botScoreEl = document.getElementById('botScore');
        const difficultyTextEl = document.getElementById('difficultyText');

        // Game variables
        let playerScore = 0;
        let botScore = 0;
        let difficulty = 'medium';
        let gameRunning = true;

        // Paddle properties
        const paddleWidth = 40;
        const paddleHeight = 40;
        const paddleRadius = 20;
        const paddleSpeed = 5;

        // Player paddle (right side)
        const playerPaddle = {
            x: canvas.width - 50,
            y: canvas.height / 2 - paddleHeight / 2,
            width: paddleWidth,
            height: paddleHeight,
            speed: paddleSpeed
        };

        // Bot paddle (left side)
        const botPaddle = {
            x: 30,
            y: canvas.height / 2 - paddleHeight / 2,
            width: paddleWidth,
            height: paddleHeight,
            speed: paddleSpeed,
            targetY: canvas.height / 2 - paddleHeight / 2,
            velocity: 0
        };

        // Ball properties
        const ball = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: 8,
            speedX: 3,
            speedY: 3,
            maxSpeed: 6,
            bounceEffect: 0,
            maxBounceEffect: 1.2
        };

        // Player characters - positions will be updated based on paddle positions
        const playerCharacter = {
            baseX: canvas.width - 100,
            x: canvas.width - 100,
            y: canvas.height / 2,
            armAngle: 0
        };

        const botCharacter = {
            baseX: 80,
            x: 80,
            y: canvas.height / 2,
            armAngle: 0
        };

        // Difficulty settings
        const difficultySettings = {
            easy: { maxSpeed: 2.5, acceleration: 0.15, prediction: 0.3 },
            medium: { maxSpeed: 3.5, acceleration: 0.2, prediction: 0.5 },
            hard: { maxSpeed: 4.5, acceleration: 0.25, prediction: 0.7 }
        };

        // Mouse control
        let mouseY = canvas.height / 2;
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseY = e.clientY - rect.top;
        });

        function setDifficulty(level) {
            difficulty = level;
            difficultyTextEl.textContent = level.toUpperCase();
            
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Find and activate the correct button
            const buttons = document.querySelectorAll('.difficulty-btn');
            buttons.forEach(btn => {
                if (btn.textContent.toLowerCase() === level) {
                    btn.classList.add('active');
                }
            });
            
            resetGame();
        }

        function drawRect(x, y, width, height, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x, y, width, height);
        }

        function drawCircle(x, y, radius, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawPlayer(character, isBot = false) {
            const x = character.x;
            const y = character.y;
            
            // Calculate body position
            const bodyY = y + 20; // Body is positioned relative to character center
            
            // Draw shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.arc(x + 2, bodyY + 52, 25, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw legs
            ctx.strokeStyle = isBot ? '#3182ce' : '#e53e3e';
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.moveTo(x - 8, bodyY + 35);
            ctx.lineTo(x - 12, bodyY + 60);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(x + 8, bodyY + 35);
            ctx.lineTo(x + 12, bodyY + 60);
            ctx.stroke();
            
            // Draw feet
            ctx.fillStyle = '#654321';
            ctx.fillRect(x - 18, bodyY + 55, 12, 8);
            ctx.fillRect(x + 6, bodyY + 55, 12, 8);
            
            // Draw body
            ctx.fillStyle = isBot ? '#4a90e2' : '#ff6b6b';
            ctx.fillRect(x - 12, bodyY + 15, 24, 35);
            
            // Draw arms - fixed length, connecting to paddles
            ctx.strokeStyle = '#fdbcb4';
            ctx.lineWidth = 6;
            
            // Get paddle positions
            const paddleX = isBot ? botPaddle.x + paddleWidth / 2 : playerPaddle.x + paddleWidth / 2;
            const paddleY = isBot ? botPaddle.y + paddleHeight / 2 : playerPaddle.y + paddleHeight / 2;
            
            // Playing arm (with paddle) - fixed length and position
            const shoulderX = isBot ? x - 15 : x + 15;
            const shoulderY = bodyY + 25;
            
            // Fixed arm length - always same distance
            const armLength = 35;
            const armAngle = Math.atan2(paddleY - shoulderY, paddleX - shoulderX);
            const elbowX = shoulderX + Math.cos(armAngle) * (armLength * 0.6);
            const elbowY = shoulderY + Math.sin(armAngle) * (armLength * 0.6);
            
            // Upper arm
            ctx.beginPath();
            ctx.moveTo(shoulderX, shoulderY);
            ctx.lineTo(elbowX, elbowY);
            ctx.stroke();
            
            // Lower arm
            ctx.beginPath();
            ctx.moveTo(elbowX, elbowY);
            ctx.lineTo(paddleX, paddleY);
            ctx.stroke();
            
            // Other arm - relaxed position
            const otherArmX = isBot ? x + 15 : x - 15;
            ctx.beginPath();
            ctx.moveTo(otherArmX, shoulderY);
            ctx.lineTo(otherArmX + (isBot ? 10 : -10), shoulderY + 15);
            ctx.stroke();
            
            // Draw head
            ctx.fillStyle = '#fdbcb4';
            ctx.beginPath();
            ctx.arc(x, bodyY, 15, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw hair
            ctx.fillStyle = isBot ? '#8B4513' : '#2c3e50';
            ctx.beginPath();
            ctx.arc(x, bodyY - 5, 12, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw eyes
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x - 5, bodyY - 2, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 5, bodyY - 2, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw smile
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, bodyY + 2, 5, 0, Math.PI);
            ctx.stroke();
            
            // Draw hands
            ctx.fillStyle = '#fdbcb4';
            ctx.beginPath();
            ctx.arc(paddleX, paddleY, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(otherArmX + (isBot ? 10 : -10), shoulderY + 15, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawPaddle(paddle, color) {
            const centerX = paddle.x + paddle.width / 2;
            const centerY = paddle.y + paddle.height / 2;
            const radius = paddle.width / 2;
            
            // Draw paddle shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.arc(centerX + 2, centerY + 2, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw handle shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            if (paddle.x > canvas.width / 2) {
                ctx.fillRect(centerX + radius - 5 + 2, centerY - 3 + 2, 15, 6);
            } else {
                ctx.fillRect(centerX - radius - 10 + 2, centerY - 3 + 2, 15, 6);
            }
            
            // Draw paddle
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw paddle border
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw handle
            ctx.fillStyle = '#8B4513';
            if (paddle.x > canvas.width / 2) {
                ctx.fillRect(centerX + radius - 5, centerY - 3, 15, 6);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(centerX + radius - 5, centerY - 3, 15, 6);
            } else {
                ctx.fillRect(centerX - radius - 10, centerY - 3, 15, 6);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(centerX - radius - 10, centerY - 3, 15, 6);
            }
            
            // Add racket texture
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 1;
            for (let i = -2; i <= 2; i++) {
                ctx.beginPath();
                ctx.moveTo(centerX + i * 8, centerY - radius + 8);
                ctx.lineTo(centerX + i * 8, centerY + radius - 8);
                ctx.stroke();
            }
            for (let i = -2; i <= 2; i++) {
                ctx.beginPath();
                ctx.moveTo(centerX - radius + 8, centerY + i * 8);
                ctx.lineTo(centerX + radius - 8, centerY + i * 8);
                ctx.stroke();
            }
        }

        function drawBall() {
            // Calculate bounce effect size
            const bounceRadius = ball.radius + ball.bounceEffect;
            
            // Draw shadow with bounce effect
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.arc(ball.x + 2, ball.y + 2, bounceRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw ball with bounce effect (slightly compressed when bouncing)
            const compressX = bounceRadius;
            const compressY = ball.radius - (ball.bounceEffect * 0.3);
            
            // Main ball with compression effect
            ctx.fillStyle = '#00bcd4';
            ctx.beginPath();
            ctx.ellipse(ball.x, ball.y, compressX, compressY, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Ball border with compression
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.ellipse(ball.x, ball.y, compressX, compressY, 0, 0, Math.PI * 2);
            ctx.stroke();
            
            // Add highlight effect during bounce
            if (ball.bounceEffect > 0.3) {
                ctx.fillStyle = `rgba(255, 255, 255, ${ball.bounceEffect * 0.5})`;
                ctx.beginPath();
                ctx.ellipse(ball.x - bounceRadius * 0.3, ball.y - bounceRadius * 0.3, 
                           bounceRadius * 0.4, bounceRadius * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Reduce bounce effect over time
            if (ball.bounceEffect > 0) {
                ball.bounceEffect -= 0.08;
                if (ball.bounceEffect < 0) ball.bounceEffect = 0;
            }
        }

        function drawMiddleLine() {
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 4;
            ctx.setLineDash([10, 10]);
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function updatePlayerPaddle() {
            const targetY = mouseY - paddleHeight / 2;
            const diff = targetY - playerPaddle.y;
            playerPaddle.y += diff * 0.1;
            
            if (playerPaddle.y < 0) playerPaddle.y = 0;
            if (playerPaddle.y > canvas.height - paddleHeight) {
                playerPaddle.y = canvas.height - paddleHeight;
            }
            
            // Update player character position to follow paddle smoothly
            const paddleCenter = playerPaddle.y + paddleHeight / 2;
            const targetCharacterY = paddleCenter - 20; // Offset to center character with paddle
            playerCharacter.y += (targetCharacterY - playerCharacter.y) * 0.15; // Smooth movement
        }

        function updateBotPaddle() {
            const settings = difficultySettings[difficulty];
            
            let predictedY = ball.y;
            if (ball.speedX < 0) {
                const timeToReach = Math.abs((ball.x - botPaddle.x) / ball.speedX);
                predictedY = ball.y + (ball.speedY * timeToReach * settings.prediction);
            }
            
            const inaccuracy = (Math.random() - 0.5) * (50 / (difficulty === 'hard' ? 3 : difficulty === 'medium' ? 2 : 1));
            botPaddle.targetY = predictedY - paddleHeight / 2 + inaccuracy;
            
            const distanceToTarget = botPaddle.targetY - botPaddle.y;
            
            if (Math.abs(distanceToTarget) > 5) {
                const desiredVelocity = distanceToTarget * 0.1;
                const clampedVelocity = Math.max(-settings.maxSpeed, Math.min(settings.maxSpeed, desiredVelocity));
                const velocityDiff = clampedVelocity - botPaddle.velocity;
                botPaddle.velocity += velocityDiff * settings.acceleration;
            } else {
                botPaddle.velocity *= 0.8;
            }
            
            botPaddle.y += botPaddle.velocity;
            
            if (botPaddle.y < 0) {
                botPaddle.y = 0;
                botPaddle.velocity = 0;
            }
            if (botPaddle.y > canvas.height - paddleHeight) {
                botPaddle.y = canvas.height - paddleHeight;
                botPaddle.velocity = 0;
            }
            
            // Update bot character position to follow paddle smoothly
            const paddleCenter = botPaddle.y + paddleHeight / 2;
            const targetCharacterY = paddleCenter - 20; // Offset to center character with paddle
            botCharacter.y += (targetCharacterY - botCharacter.y) * 0.15; // Smooth movement like player
        }

        function updateBall() {
            ball.x += ball.speedX;
            ball.y += ball.speedY;

            if (ball.y <= ball.radius || ball.y >= canvas.height - ball.radius) {
                ball.speedY = -ball.speedY;
                // Add bounce effect when hitting top/bottom walls
                ball.bounceEffect = ball.maxBounceEffect * 0.7;
            }

            // Ball collision with player paddle
            const playerCenterX = playerPaddle.x + paddleWidth / 2;
            const playerCenterY = playerPaddle.y + paddleHeight / 2;
            const distToPlayer = Math.sqrt(
                Math.pow(ball.x - playerCenterX, 2) + Math.pow(ball.y - playerCenterY, 2)
            );
            
            if (distToPlayer <= ball.radius + paddleRadius && ball.speedX > 0) {
                ball.speedX = -Math.abs(ball.speedX);
                const hitAngle = Math.atan2(ball.y - playerCenterY, ball.x - playerCenterX);
                ball.speedY = Math.sin(hitAngle) * 4;
                
                // Add bounce effect to ball
                ball.bounceEffect = ball.maxBounceEffect;
                
                // Add swing animation
                playerCharacter.armAngle += 0.5;
                
                if (Math.abs(ball.speedX) < ball.maxSpeed) {
                    ball.speedX *= 1.05;
                }
            }

            // Ball collision with bot paddle
            const botCenterX = botPaddle.x + paddleWidth / 2;
            const botCenterY = botPaddle.y + paddleHeight / 2;
            const distToBot = Math.sqrt(
                Math.pow(ball.x - botCenterX, 2) + Math.pow(ball.y - botCenterY, 2)
            );
            
            if (distToBot <= ball.radius + paddleRadius && ball.speedX < 0) {
                ball.speedX = Math.abs(ball.speedX);
                const hitAngle = Math.atan2(ball.y - botCenterY, ball.x - botCenterX);
                ball.speedY = Math.sin(hitAngle) * 4;
                
                // Add bounce effect to ball
                ball.bounceEffect = ball.maxBounceEffect;
                
                // Add swing animation
                botCharacter.armAngle -= 0.5;
                
                if (Math.abs(ball.speedX) < ball.maxSpeed) {
                    ball.speedX *= 1.05;
                }
            }

            // Score points
            if (ball.x < 0) {
                playerScore++;
                playerScoreEl.textContent = playerScore;
                resetBall();
                checkGameEnd();
            } else if (ball.x > canvas.width) {
                botScore++;
                botScoreEl.textContent = botScore;
                resetBall();
                checkGameEnd();
            }
        }

        function resetBall() {
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;
            ball.speedX = (Math.random() > 0.5 ? 1 : -1) * 3;
            ball.speedY = (Math.random() > 0.5 ? 1 : -1) * 3;
            ball.bounceEffect = 0; // Reset bounce effect
        }

        function checkGameEnd() {
            if (playerScore >= 5 || botScore >= 5) {
                setTimeout(() => {
                    const winner = playerScore >= 5 ? 'Player' : 'Bot';
                    alert(`${winner} Wins!`);
                    resetGame();
                }, 100);
            }
        }

        function resetGame() {
            playerScore = 0;
            botScore = 0;
            playerScoreEl.textContent = '0';
            botScoreEl.textContent = '0';
            resetBall();
            
            playerPaddle.y = canvas.height / 2 - paddleHeight / 2;
            botPaddle.y = canvas.height / 2 - paddleHeight / 2;
            botPaddle.targetY = canvas.height / 2 - paddleHeight / 2;
            botPaddle.velocity = 0;
            
            // Reset character positions
            playerCharacter.y = canvas.height / 2;
            playerCharacter.armAngle = 0;
            botCharacter.y = canvas.height / 2;
            botCharacter.armAngle = 0;
        }

        function gameLoop() {
            if (!gameRunning) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            updatePlayerPaddle();
            updateBotPaddle();
            updateBall();

            drawMiddleLine();
            drawPlayer(playerCharacter, false); // Player (right side)
            drawPlayer(botCharacter, true); // Bot (left side)
            drawPaddle(playerPaddle, '#e53e3e');
            drawPaddle(botPaddle, '#3182ce');
            drawBall();

            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>